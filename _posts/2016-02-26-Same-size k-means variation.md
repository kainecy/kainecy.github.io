---
layout: post
title: 相同大小的K均值变化算法
---

###算法基本如下：  
####初始化：  
1. 计算所需要的簇大小。  
2. 初始化质点，最好使用k-means++算法。  
3. 点到离他最近的簇的距离，减去到离他最远的簇的距离（=最好和最坏分配的最大利益）。  
4. 分配点到他们的首选簇，直到这个簇是完整的，然后分配其余的点而不再考虑已经完整的簇。  

这个初始化方法不是最佳的，对于本教程还有改进的空间，特别是最后一个簇。但这将作为一个初始化方法。  

附加数据结构：对于每一个簇，我们都要保留一个愿意离开集群的对象列表。这样将更容易得找到转移候选人。当有一个点，想要进入一个簇，想要离开他的顶部元素被认为是切换。（或许也可以考虑更多的顶部元素）  

####迭代
1. 计算当前簇的方法
2. 对于每一个点，计算他到簇的距离
3. 根据当前分配任务和最佳替代分配排序元素
4. 对每个元素的优先级：  
对于每个其他集群，由元素增益，除非已经移动：  
    1）如果有一个元素想要离开其他的簇和这个交换之后的收益率有改善，则交换2个元素  
    2）如果该元素可以移动而不违反大小限制，移动他  
    3）如果元素没有更改，添加到输出转移列表  
    4）如果没有更多的转移，或者达到最大迭代阈值，终止  

收敛性与K均值相同：任何一个转移都必须减少方差，也可能是K均值。  

改进空间：寻找最佳转移的逻辑，如：通过求解三角形，对象1从A到B，对象2从B到C，对象3从C到A，仍然保留大小。


##自动生成代码
由于这是一个K均值变化，我们可以使用基类AbstractKMeans。生成标准方法，添加一个记录器，选择泛型属性。  

